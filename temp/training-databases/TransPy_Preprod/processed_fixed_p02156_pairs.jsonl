{"input": "translate Python to C++: from collections import deque\n\nN,M = map(int,input().split())\nU = input()\nA = list(map(int,input().split()))\nsrc = [tuple(map(int,input().split())) for i in range(M)]\n\nedges = {}\nfor s,t,b in src:\n    s,t = s-1,t-1\n    if s>t: s,t = t,s\n    if (s,t) in edges:\n        edges[(s,t)] += b\n    else:\n        edges[(s,t)] = b\n\nP = N+2\nes = [[] for i in range(P)] # [[to1,cap1,rev1], ...]\n\ndef add_edge(fr,to,cap):\n    es[fr].append([to,cap,len(es[to])])\n    es[to].append([fr,0,len(es[fr])-1])\n\nfor i,(u,a) in enumerate(zip(U,A)):\n    if u == 'L':\n        add_edge(0,i+2,a)\n        add_edge(i+2,1,0)\n    else:\n        add_edge(0,i+2,0)\n        add_edge(i+2,1,a)\nfor (s,t),b in edges.items():\n    add_edge(t+2,s+2,b)\n\nINF = float('inf')\nlevel = [0] * P\niters = [0] * P\n\ndef dinic_max_flow(s,t):\n    global iters\n\n    def _bfs(s):\n        global level\n        level = [-1] * P\n        level[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for to,cap,rev in es[v]:\n                if cap > 0 and level[to] < 0:\n                    level[to] = level[v] + 1\n                    q.append(to)\n\n    def _dfs(v,t,f):\n        if v == t: return f\n        for i in range(iters[v],len(es[v])):\n            iters[v] += 1\n            to,cap,rev = es[v][i]\n            if es[v][i][1] > 0 and level[v] < level[to]:\n                d = _dfs(to,t,min(f,es[v][i][1]))\n                if d > 0:\n                    es[v][i][1] -= d #cap\n                    es[to][rev][1] += d\n                    return d\n        return 0\n\n    flow = 0\n    while True:\n        _bfs(s)\n        if level[t] < 0: return flow\n        iters = [0] * P\n        f = 0\n        while True:\n            f = _dfs(s,t,INF)\n            if f <= 0: break\n            flow += f\n\nprint(dinic_max_flow(0,1))\n\nGiven input: 3 1\nRRL\n5 5 1\n3 1 10\n\nExpected output: 1\n", "output": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 rev;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Dinic {\n  int N;\n  vector<int> level;\n  vector<int> itr;\n  Graph G;\n\n  Dinic(int n) : G(n) { N = n; }\n\n  void add_edge(int from, int to, i64 cap, i64 rev_cap) {\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1});\n  }\n\n  bool g_level(int s, int t) {\n    level.assign(N, -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (auto &e : G[v]) {\n        if (e.cap > 0 && level[e.to] == -1) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] >= 0;\n  }\n\n  i64 dfs(int v, int t, i64 f) {\n    if (v == t) return f;\n\n    for (int &i = itr[v]; i < G[v].size(); i++) {\n      auto &e = G[v][i];\n      if (e.cap > 0 && level[e.to] > level[v]) {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0) {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n\n  i64 max_flow(int s, int t) {\n    i64 result = 0;\n    i64 flow;\n    while (g_level(s, t)) {\n      itr.assign(N, 0);\n      while ((flow = dfs(s, t, 1e9)) > 0) result += flow;\n    }\n    return result;\n  }\n};\n\n/*\nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\n\nint N,M;\n\nstring U;\n\ni64 A[505];\n\ni64 S[1010];\ni64 T[1010];\ni64 B[1010];\n\ni64 cost[505][505];\n\ni64 f[505];\n\n\nint main() {\n\n  cin >> N >> M;\n  cin >> U;\n  for(int i = 0;i < N;i++) {\n    if(U[i] == 'R') f[i] = 1;\n    else f[i] = -1;\n  }\n  for(int i = 0;i < N;i++) cin >> A[i];\n  for(int j = 0;j < M;j++) cin >> S[j] >> T[j] >> B[j];\n\n  for(int j = 0;j < M;j++) {\n    S[j]--;\n    T[j]--;\n    cost[min(S[j], T[j])][max(S[j], T[j])] += B[j];\n  }\n\n  Dinic pd(N + 10);\n  int s = N;\n  int t = N + 1;\n\n  for(int i = 0;i < N;i++) {\n    if(f[i] == 1) {\n      pd.add_edge(s, i, 0, 0);\n      pd.add_edge(i, t, A[i], 0);\n    }\n    else {\n\n      pd.add_edge(s, i, A[i], 0);\n      pd.add_edge(i, t, 0, 0);\n    }\n    for(int j = i + 1;j < N;j++) {\n      if(cost[i][j] > 0) {\n        pd.add_edge(j, i, cost[i][j], 0);\n      }\n    }\n  }\n\n  cout << pd.max_flow(s, t) << endl;\n}\n\n"}
