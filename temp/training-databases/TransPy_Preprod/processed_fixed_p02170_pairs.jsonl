{"input": "translate Python to C++: #!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 998244353\n\n\ndef solve():\n    n,k,a = LI()\n    lst = [0]*(k+1)\n    lst[-2] = 1\n    A = a*pow(100*n,mod-2,mod)\n    inv = pow(n,mod-2,mod)\n\n    for i in range(k-1)[::-1]:\n        if k > i + n:\n            lst[i] = A*(lst[i+1] - lst[i+n+1]) + lst[i+1]\n            lst[i] %= mod\n        else:\n            lst[i] = A*(lst[i+1] - lst[k]) + (n-(k-i)+1)*inv + lst[i+1]\n            lst[i] %= mod\n    print((lst[0] - lst[1])%mod)\n    return\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\nGiven input: 1 1 50\n\nExpected output: 1\n", "output": "#include <iostream>\n#include <vector>\n\nusing std::vector;\n\ntemplate <int MOD>\nclass ModInt {\n    using lint = long long;\n\npublic:\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // assignment\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->val = x.val; }\n        return *this;\n    }\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator~() const { return *this ^ (MOD - 2); }\n\n    // increment / decrement\n    ModInt& operator++() { return *this += 1; }\n    ModInt& operator--() { return *this -= 1; }\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator%(const ModInt& x) const { return ModInt(*this) %= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt operator^(const ModInt& x) const { return ModInt(*this) ^= x; }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator%=(const ModInt& x) {\n        val %= x.val;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= ~x; }\n    ModInt& operator^=(const ModInt& x) {\n        int n = x.val;\n        ModInt b = *this;\n        if (n < 0) n = -n, b = ~b;\n\n        *this = 1;\n        while (n > 0) {\n            if (n & 1) *this *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n};\n\nusing mint = ModInt<998244353>;\n\nint main() {\n    int n, k, a;\n    std::cin >> n >> k >> a;\n    mint succ = mint(a) / 100;\n\n    vector<mint> dp(n + k), dpsum(n + k);\n    dp[0] = dpsum[0] = 1;\n    for (int i = 1; i < n + k; ++i) {\n        mint prev = dpsum[std::min(i, k) - 1] -\n                    (i - n - 1 >= 0 ? dpsum[i - n - 1] : 0);\n        dp[i] = prev / n * succ;\n        dpsum[i] = dpsum[i - 1] + dp[i];\n    }\n\n    mint ans = dpsum[n + k - 1] - dpsum[k - 1];\n    std::cout << ans / succ << std::endl;\n    return 0;\n}\n\n"}
{"input": "translate Python to C++: N, K, A = map(int, input().split())\ndp = [0] * (K+1) + [1] * N  # \u6b8b\u308a\u304c i \u70b9\u306e\u3068\u304d\u306e\u52dd\u7387\ndp[0] = 1\nc = 1\nmod = 998244353\np_coin = A * pow(100, mod-2, mod) % mod\np_dice = pow(N, mod-2, mod)\nfor i in range(1, K+1):\n    dp[i] = c * p_coin % mod\n    c += (dp[i] - dp[i-N]) * p_dice % mod\nprint(dp[K] * pow(p_coin, mod-2, mod) % mod)\n\n\nGiven input: 1 1 50\n\nExpected output: 1\n", "output": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 998244353;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i = (m); i < (n); i++)\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \\n\"[i==n-1];};\nstruct Combination{\nprivate:\n    ll N;\n    vector<ll> fac, facinv;\n\npublic:\n    Combination(ll n){\n        N = n;\n        fac.push_back(1); fac.push_back(1);\n        rep(i,2,N+1) fac.push_back(fac[i-1] * i % MOD);\n        rep(i,0,N+1) facinv.push_back(power(fac[i], MOD-2));\n    }\n    ll power(ll x, ll n){\n        if(n == 0) return 1LL;\n        ll res = power(x * x % MOD, n/2);\n        if(n % 2 == 1) res = res * x % MOD;\n        return res;\n    }\n    ll nck(ll n, ll k){\n        if(k == 0 || n == k) return 1LL;\n        return fac[n] * facinv[k] % MOD * facinv[n-k] % MOD;\n    }\n    ll npk(ll n, ll k){\n        if(k == 0 || n == k) return 1LL;\n        return fac[n] * facinv[n-k] % MOD;\n    }\n    ll get(ll x){return fac[x];};\n    ll getinv(ll x){return facinv[x];};\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll N,K,A;\n\tcin >> N >> K >> A;\n\tCombination cb(10);\n\tll sum[200010] = {};\n\tll val[200010] = {};\n\tll inv = cb.power(N, MOD-2);\n\tval[1] = inv;\n\tsum[1] = val[1];\n\trep(i,2,N+K){\n\t\tll tt = (sum[min(K-1, i-1)] - sum[max(0LL, i-N-1)] + MOD) % MOD;\n\t\ttt *= A * cb.power(100LL, MOD-2) % MOD * inv % MOD;\n\t\ttt %= MOD;\n\t\tif(i <= N){\n\t\t\t(tt += inv) %= MOD;\n\t\t}\n\t\tval[i] = tt;\n\t\tsum[i] = (sum[i-1] + val[i]) % MOD;\n\t\tsum[i] %= MOD;\n\t}\n\tll ans = 0;\n\trep(i,K,N+K){\n\t\t(ans += val[i]) %= MOD;\n\t}\n\tprint(ans);\n}\n"}
