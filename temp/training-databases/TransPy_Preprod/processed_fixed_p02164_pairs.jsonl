{"input": "translate Python to C++: from math import atan2, degrees\nfrom itertools import permutations\n\nN = int(input())\nXY = [list(map(int, input().split())) for _ in range(N)]\npx = py = 0\nans = float(\"inf\")\nfor t in permutations(XY):\n    a = 0\n    deg = 0\n    for x, y in t + ([0, 0],):\n        d = degrees(atan2(y-py, x-px))\n        delta = deg - d\n        if delta < 0: delta += 360\n        if delta > 180: delta = 360 - delta\n        a += delta\n\n        px, py = x, y\n        deg = d\n    ans = min(a, ans)\nprint(ans)\n\n\nGiven input: 2\n0 1\n0 -1\n\nExpected output: 450.00000000\n", "output": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nusing W = double;\nusing P = complex<W>;\nconstexpr W pi = acos(-1);\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps;\n  for(int i = 0; i < N; ++i){\n    W x, y;\n    cin >> x >> y;\n    ps.emplace_back(x,y);\n  }\n  vector<int> I(N);\n  for(int i = 0; i < N; ++i) I[i] = i;\n  W ans = 1e18;\n  do{\n    P s(0,0), d(1,0);\n    W t = 0;\n    for(int i = 0; i < N; ++i){\n      W a = abs(arg((ps[I[i]]-s)/d));\n      t += a;\n      d = (ps[I[i]]-s)/abs((ps[I[i]]-s));\n      s = ps[I[i]];\n    }\n    t += abs(arg((P(0,0)-s)/d));\n    ans = min(ans,t);\n  }while(next_permutation(I.begin(), I.end()));\n  ans *= 180./pi;\n  printf(\"%.12f\\n\",ans);\n}\n\n"}
{"input": "translate Python to C++: #!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n\ndef solve():\n    from itertools import permutations\n    def dot(a,b):\n        return sum(list(map(lambda x : x[0]*x[1], zip(a,b))))\n\n    n = I()\n    p = LIR(n)\n    ans = float(\"inf\")\n    for l in permutations(range(n),n):\n        x,y = [0,0]\n        m = 0\n        v = [1,0]\n        for i in l:\n            s,t = p[i]\n            nv = [s-x,t-y]\n            m += math.acos(dot(v,nv)/(dot(v,v)*dot(nv,nv))**0.5)\n            x,y = s,t\n            v = [nv[0],nv[1]]\n        s,t = 0,0\n        nv = [s-x,t-y]\n        m += math.acos(dot(v,nv)/(dot(v,v)*dot(nv,nv))**0.5)\n        ans = min(ans, m)\n    print(ans*180/math.pi)\n    return\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\nGiven input: 2\n0 1\n0 -1\n\nExpected output: 450.00000000\n", "output": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\n\nusing D = double;\nconst D PI = asin(1)*2;\nD dot(D x1,D y1,D x2,D y2){\n  return x1*x2+y1*y2;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  vector<D> xs(n),ys(n);\n  for(int i=0;i<n;i++) cin>>xs[i]>>ys[i];\n  xs.emplace_back(0);\n  ys.emplace_back(0);\n  xs.emplace_back(-1);\n  ys.emplace_back(0);\n\n  vector<int> vs(n+3,n),used(n,0);\n  vs[0]=n+1;\n\n  D ans=1e9;\n  auto check=\n    [&](){\n      D res=0;\n      for(int i=0;i+2<n+3;i++){\n        D dx=xs[vs[i+1]]-xs[vs[i+0]],dy=ys[vs[i+1]]-ys[vs[i+0]];\n        D nx=xs[vs[i+2]]-xs[vs[i+1]],ny=ys[vs[i+2]]-ys[vs[i+1]];\n        D th=acos(min(1.0,max(dot(dx,dy,nx,ny)/hypot(dx,dy)/hypot(nx,ny),\n                          -1.0)));\n        //cout<<dx<<\" \"<<dy<<\":\"<<nx<<\" \"<<ny<<\":\"<<th<<endl;\n        res+=abs(th)/PI*180;\n      }\n      chmin(ans,res);\n    };\n\n  MFP([&](auto dfs,int d)->void{\n        if(d==n+2){\n          check();\n          return;\n        }\n        for(int i=0;i<n;i++){\n          if(used[i]) continue;\n          used[i]=1;\n          vs[d]=i;\n          dfs(d+1);\n          used[i]=0;\n        }\n      })(2);\n\n  cout<<ans<<endl;\n  return 0;\n}\n\n"}
